<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sumkurve med kumulativ frekvens + histogram</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      max-width: 900px;
    }
    textarea {
      width: 100%;
      height: 100px;
      font-size: 14px;
      margin-bottom: 1em;
    }
    input[type="number"] {
      width: 80px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 1em;
    }
    th, td {
      border: 1px solid #aaa;
      padding: 6px 8px;
      text-align: center;
    }
    th {
      background-color: #eee;
    }
    #sumkurveCanvas, #histogramCanvas {
      max-width: 100%;
      height: 300px;
      margin-top: 30px;
      margin-bottom: 30px;
    }
    .flex-row {
      display: flex;
      gap: 15px;
      margin-bottom: 1em;
      flex-wrap: wrap;
      align-items: center;
    }
    label {
      margin-right: 5px;
    }
    button {
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Sumkurve med kumulativ frekvens + histogram</h1>

  <p>Indtast intervaller (f.eks. 0-10) og hyppigheder, Ã©n pr. linje:</p>
  <textarea id="intervals" placeholder="fx&#10;0-10&#10;10-20&#10;20-30"></textarea>
  <textarea id="frequencies" placeholder="fx&#10;5&#10;12&#10;8"></textarea>

  <button onclick="processData()">Beregn og vis sumkurve + histogram</button>

  <div id="results"></div>

  <canvas id="sumkurveCanvas"></canvas>

  <!-- Beregningsfelter og resultater -->
  <div class="flex-row">
    <div>
      <label for="fraktilInput1">p-fraktil (0â€“1):</label>
      <input id="fraktilInput1" type="number" step="0.01" min="0" max="1" />
    </div>
    <div>
      <label for="fraktilInput2">p-fraktil (0â€“1):</label>
      <input id="fraktilInput2" type="number" step="0.01" min="0" max="1" />
    </div>
    <div>
      <label for="fraktilInput3">p-fraktil (0â€“1):</label>
      <input id="fraktilInput3" type="number" step="0.01" min="0" max="1" />
    </div>
  </div>

  <div class="flex-row">
    <div>
      <label for="xInput1">x-vÃ¦rdi:</label>
      <input id="xInput1" type="number" step="any" />
    </div>
    <div>
      <label for="xInput2">x-vÃ¦rdi:</label>
      <input id="xInput2" type="number" step="any" />
    </div>
    <div>
      <label for="xInput3">x-vÃ¦rdi:</label>
      <input id="xInput3" type="number" step="any" />
    </div>
  </div>

  <button onclick="beregnFraktiler()">Beregn fraktiler / p-vÃ¦rdier</button>

  <div id="fraktilResultat" style="margin-top: 1em; font-weight: bold;"></div>

  <!-- Histogram -->
  <canvas id="histogramCanvas"></canvas>

<script>
let globalData = {};
let sumChart;
let histogramChart;

function processData() {
  const intervalsRaw = document.getElementById("intervals").value.trim();
  const frequenciesRaw = document.getElementById("frequencies").value.trim();
  if (!intervalsRaw || !frequenciesRaw) {
    alert("Indtast venligst bÃ¥de intervaller og hyppigheder.");
    return;
  }
  const intervals = intervalsRaw.split("\n").map(line => {
    const parts = line.trim().split("-");
    if (parts.length !== 2) {
      alert("Intervaller skal vÃ¦re pÃ¥ formatet a-b");
      throw new Error("Forkert interval format");
    }
    return [Number(parts[0]), Number(parts[1])];
  });
  const frequencies = frequenciesRaw.split("\n").map(x => Number(x.trim()));

  if (intervals.length !== frequencies.length) {
    alert("Antallet af intervaller og hyppigheder skal vÃ¦re det samme.");
    return;
  }

  const N = frequencies.reduce((a, b) => a + b, 0);
  if (N === 0) {
    alert("Samlet hyppighed mÃ¥ ikke vÃ¦re nul.");
    return;
  }
  const midpoints = intervals.map(([a, b]) => (a + b) / 2);
  const mean = frequencies.reduce((sum, f, i) => sum + f * midpoints[i], 0) / N;
  const varPop = frequencies.reduce((sum, f, i) => sum + f * (midpoints[i] - mean) ** 2, 0) / N;
  const stdPop = Math.sqrt(varPop);
  const varSample = N > 1 ? frequencies.reduce((sum, f, i) => sum + f * (midpoints[i] - mean) ** 2, 0) / (N - 1) : NaN;
  const stdSample = Math.sqrt(varSample);
  const cumFreq = [];
  let sum = 0;
  for (let f of frequencies) {
    sum += f;
    cumFreq.push(sum);
  }

  const rows = intervals.map((interval, i) => {
    return `
      <tr>
        <td>${interval[0]}â€“${interval[1]}</td>
        <td>${frequencies[i]}</td>
        <td>${midpoints[i].toFixed(2)}</td>
        <td>${cumFreq[i]}</td>
        <td>${(cumFreq[i] / N * 100).toFixed(2)}%</td>
      </tr>`;
  });

  document.getElementById("results").innerHTML = `
    <div id="exportContent">
      <h2>ðŸ“Š Oversigt over data</h2>
      <table>
        <tr><th>Interval</th><th>Hyppighed</th><th>Midtpunkt</th><th>Kum. hyppighed</th><th>Kum. frekvens (%)</th></tr>
        ${rows.join("")}
      </table>
      <h2>ðŸ“‹ Statistik</h2>
      <table>
        <tr><th>Parameter</th><th>VÃ¦rdi</th></tr>
        <tr><td>n</td><td>${N}</td></tr>
        <tr><td>MiddelvÃ¦rdi</td><td>${mean.toFixed(2)}</td></tr>
        <tr><td>Populationsvarians</td><td>${varPop.toFixed(2)}</td></tr>
        <tr><td>Populationsspredning</td><td>${stdPop.toFixed(2)}</td></tr>
        <tr><td>StikprÃ¸vevarians</td><td>${varSample.toFixed(2)}</td></tr>
        <tr><td>StikprÃ¸vespredning</td><td>${stdSample.toFixed(2)}</td></tr>
      </table>
    </div>`;

  globalData = { intervals, frequencies, N, cumFreq, midpoints };

  showSumkurve();
  showHistogram();
  document.getElementById("fraktilResultat").innerHTML = "";
}

function interpolateXforP(p) {
  const { intervals, frequencies, N, cumFreq } = globalData;
  if (!intervals) return null;
  const target = p * N;
  for (let i = 0; i < frequencies.length; i++) {
    if (cumFreq[i] >= target) {
      const [a, b] = intervals[i];
      const F = i > 0 ? cumFreq[i - 1] : 0;
      const f_i = frequencies[i];
      const h = b - a;
      const xVal = a + ((target - F) / f_i) * h;
      return xVal;
    }
  }
  return null;
}

function interpolatePforX(x) {
  const { intervals, frequencies, N, cumFreq } = globalData;
  if (!intervals) return null;
  for (let i = 0; i < intervals.length; i++) {
    const [a, b] = intervals[i];
    if (x <= b) {
      const F = i > 0 ? cumFreq[i - 1] : 0;
      const f_i = frequencies[i];
      const h = b - a;
      const pVal = (F + f_i * (x - a) / h) / N;
      return pVal;
    }
  }
  return 1;
}

function showSumkurve() {
  const { intervals, cumFreq, N } = globalData;
  if (!intervals) return;
  const canvas = document.getElementById("sumkurveCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = canvas.clientWidth;
  canvas.height = 300;

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Tegn akser
  ctx.beginPath();
  ctx.moveTo(50, 10);
  ctx.lineTo(50, 280);
  ctx.lineTo(850, 280);
  ctx.strokeStyle = "black";
  ctx.lineWidth = 2;
  ctx.stroke();

  // Skaleringsparametre
  const xMin = intervals[0][0];
  const xMax = intervals[intervals.length - 1][1];
  const yMax = N;

  // Tegn kumulativ frekvens trin
  ctx.beginPath();
  ctx.strokeStyle = "red";
  ctx.lineWidth = 2;
  let px = 50;
  let py = 280;
  ctx.moveTo(px, py);
  for (let i = 0; i < intervals.length; i++) {
    const [a, b] = intervals[i];
    const y = 280 - (cumFreq[i] / yMax) * 270;
    const xA = 50 + ((a - xMin) / (xMax - xMin)) * 800;
    const xB = 50 + ((b - xMin) / (xMax - xMin)) * 800;
    ctx.lineTo(xA, py);
    ctx.lineTo(xB, y);
    px = xB;
    py = y;
  }
  ctx.stroke();

  // Gem kontekst globalt for andre funktioner
  window.ctx = ctx;
  window.xMin = xMin;
  window.xMax = xMax;
  window.yMax = yMax;

  // Tegn akseetiketter
  ctx.fillStyle = "black";
  ctx.font = "14px Arial";
  ctx.fillText("x", 860, 285);
  ctx.fillText("Kumulativ hyppighed", 5, 20);

  // Tegn streger langs x-aksen for intervalgrÃ¦nser
  ctx.strokeStyle = "#ccc";
  ctx.lineWidth = 1;
  intervals.forEach(([a,b]) => {
    const x = 50 + ((a - xMin) / (xMax - xMin)) * 800;
    ctx.beginPath();
    ctx.moveTo(x, 280);
    ctx.lineTo(x, 270);
    ctx.stroke();
    ctx.fillText(a, x-10, 295);
  });
  // Sidste interval slutvÃ¦rdi
  const xEnd = 50 + ((intervals[intervals.length-1][1] - xMin) / (xMax - xMin)) * 800;
  ctx.fillText(intervals[intervals.length-1][1], xEnd-10, 295);
}

function drawDottedLine(ctx, x1, y1, x2, y2, color) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 5]);
  // Skaler til canvas koordinater
  const canvasX1 = 50 + ((x1 - window.xMin) / (window.xMax - window.xMin)) * 800;
  const canvasX2 = 50 + ((x2 - window.xMin) / (window.xMax - window.xMin)) * 800;
  const canvasY1 = 280 - (y1 / window.yMax) * 270;
  const canvasY2 = 280 - (y2 / window.yMax) * 270;
  ctx.beginPath();
  ctx.moveTo(canvasX1, canvasY1);
  ctx.lineTo(canvasX2, canvasY2);
  ctx.stroke();
  ctx.restore();
}

function beregnFraktiler() {
  // Hent og filtrer p-fraktil input: kun tal mellem 0 og 1 (eksklusiv)
  const pInputsRaw = [
    document.getElementById("fraktilInput1").value,
    document.getElementById("fraktilInput2").value,
    document.getElementById("fraktilInput3").value,
  ];
  const pInputs = pInputsRaw
    .map(v => v.trim())
    .filter(v => v !== "")  // kun ikke-tomme felter
    .map(v => Number(v))
    .filter(v => !isNaN(v) && v > 0 && v < 1);

  // Hent og filtrer x-vÃ¦rdi input: kun gyldige tal
  const xInputsRaw = [
    document.getElementById("xInput1").value,
    document.getElementById("xInput2").value,
    document.getElementById("xInput3").value,
  ];
  const xInputs = xInputsRaw
    .map(v => v.trim())
    .filter(v => v !== "")
    .map(v => Number(v))
    .filter(v => !isNaN(v));

  if (pInputs.length === 0 && xInputs.length === 0) {
    document.getElementById("fraktilResultat").textContent = "Indtast venligst mindst Ã©n gyldig p-fraktil eller x-vÃ¦rdi.";
    return;
  }

  const fraktiler = [];
  for (let p of pInputs) {
    const xVal = interpolateXforP(p);
    if (xVal !== null) fraktiler.push({ p, xVal });
  }

  const pVaerdier = [];
  for (let x of xInputs) {
    const pVal = interpolatePforX(x);
    if (pVal !== null) pVaerdier.push({ x, pVal });
  }

  // GenindlÃ¦s sumkurve uden ekstra linjer fÃ¸rst
  showSumkurve();

  // Tegn stiplede linjer for fraktiler (grÃ¸n)
  fraktiler.forEach(({ p, xVal }) => {
    drawDottedLine(window.ctx, xVal, 0, xVal, p * globalData.N, "green");
    drawDottedLine(window.ctx, 0, p * globalData.N, xVal, p * globalData.N, "green");
  });

  // Tegn stiplede linjer for p-vÃ¦rdier (blÃ¥)
  pVaerdier.forEach(({ x, pVal }) => {
    drawDottedLine(window.ctx, x, 0, x, pVal * globalData.N, "blue");
    drawDottedLine(window.ctx, 0, pVal * globalData.N, x, pVal * globalData.N, "blue");
  });

  // Vis resultattekst
  let tekst = "";
  if (fraktiler.length > 0) {
    tekst += "Fraktiler:\n";
    fraktiler.forEach(({ p, xVal }) => {
      tekst += `p = ${p.toFixed(3)} â†’ x = ${xVal.toFixed(3)}\n`;
    });
  }
  if (pVaerdier.length > 0) {
    tekst += (tekst ? "\n" : "") + "P-vÃ¦rdier:\n";
    pVaerdier.forEach(({ x, pVal }) => {
      tekst += `x = ${x.toFixed(3)} â†’ p = ${pVal.toFixed(3)}\n`;
    });
  }
  document.getElementById("fraktilResultat").textContent = tekst.trim();
}

function showHistogram() {
  const { intervals, frequencies } = globalData;
  if (!intervals) return;
  const ctx = document.getElementById("histogramCanvas").getContext("2d");

  if (histogramChart) {
    histogramChart.destroy();
  }

  const labels = intervals.map(i => `${i[0]}â€“${i[1]}`);
  histogramChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "Hyppighed",
        data: frequencies,
        backgroundColor: "rgba(54, 162, 235, 0.6)",
        borderColor: "rgba(54, 162, 235, 1)",
        borderWidth: 1,
      }]
    },
    options: {
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: "Hyppighed"
          }
        },
        x: {
          title: {
            display: true,
            text: "Intervaller"
          }
        }
      }
    }
  });
}
</script>
</body>
</html>
