<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sumkurve med kumulativ frekvens + histogram</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      max-width: 900px;
    }
    textarea {
      width: 100%;
      height: 100px;
      font-size: 14px;
      margin-bottom: 1em;
    }
    input[type="number"] {
      width: 80px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 1em;
    }
    th, td {
      border: 1px solid #aaa;
      padding: 6px 8px;
      text-align: center;
    }
    th {
      background-color: #eee;
    }
    #sumkurveCanvas, #histogramCanvas {
      max-width: 100%;
      height: 300px;
      margin-top: 30px;
      margin-bottom: 30px;
    }
    .flex-row {
      display: flex;
      gap: 15px;
      margin-bottom: 1em;
      flex-wrap: wrap;
      align-items: center;
    }
    label {
      margin-right: 5px;
    }
    button {
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Sumkurve med kumulativ frekvens + histogram</h1>

  <p>Indtast intervaller (f.eks. 0-10) og hyppigheder, Ã©n pr. linje:</p>
  <textarea id="intervals" placeholder="fx&#10;0-10&#10;10-20&#10;20-30"></textarea>
  <textarea id="frequencies" placeholder="fx&#10;5&#10;12&#10;8"></textarea>

  <button onclick="processData()">Beregn og vis sumkurve + histogram</button>

  <div id="results"></div>

  <canvas id="sumkurveCanvas"></canvas>

  <!-- Beregningsfelter og resultater -->
  <div class="flex-row">
    <div>
      <label for="fraktilInput1">p-fraktil (0â€“1):</label>
      <input id="fraktilInput1" type="number" step="0.01" min="0" max="1" />
    </div>
    <div>
      <label for="fraktilInput2">p-fraktil (0â€“1):</label>
      <input id="fraktilInput2" type="number" step="0.01" min="0" max="1" />
    </div>
    <div>
      <label for="fraktilInput3">p-fraktil (0â€“1):</label>
      <input id="fraktilInput3" type="number" step="0.01" min="0" max="1" />
    </div>
  </div>

  <div class="flex-row">
    <div>
      <label for="xInput1">x-vÃ¦rdi:</label>
      <input id="xInput1" type="number" step="any" />
    </div>
    <div>
      <label for="xInput2">x-vÃ¦rdi:</label>
      <input id="xInput2" type="number" step="any" />
    </div>
    <div>
      <label for="xInput3">x-vÃ¦rdi:</label>
      <input id="xInput3" type="number" step="any" />
    </div>
  </div>

  <button onclick="beregnFraktiler()">Beregn fraktiler / p-vÃ¦rdier</button>

  <div id="fraktilResultat" style="margin-top: 1em; font-weight: bold; white-space: pre-line;"></div>

  <!-- Histogram -->
  <canvas id="histogramCanvas"></canvas>

<script>
let globalData = {};
let sumChart;
let histogramChart;

function processData() {
  const intervalsRaw = document.getElementById("intervals").value.trim();
  const frequenciesRaw = document.getElementById("frequencies").value.trim();
  if (!intervalsRaw || !frequenciesRaw) {
    alert("Indtast venligst bÃ¥de intervaller og hyppigheder.");
    return;
  }
  const intervals = intervalsRaw.split("\n").map(line => {
    const parts = line.trim().split("-");
    if (parts.length !== 2) {
      alert("Intervaller skal vÃ¦re pÃ¥ formatet a-b");
      throw new Error("Forkert interval format");
    }
    return [Number(parts[0]), Number(parts[1])];
  });
  const frequencies = frequenciesRaw.split("\n").map(x => Number(x.trim()));

  if (intervals.length !== frequencies.length) {
    alert("Antallet af intervaller og hyppigheder skal vÃ¦re det samme.");
    return;
  }

  const N = frequencies.reduce((a, b) => a + b, 0);
  if (N === 0) {
    alert("Samlet hyppighed mÃ¥ ikke vÃ¦re nul.");
    return;
  }
  const midpoints = intervals.map(([a, b]) => (a + b) / 2);
  const mean = frequencies.reduce((sum, f, i) => sum + f * midpoints[i], 0) / N;
  const varPop = frequencies.reduce((sum, f, i) => sum + f * (midpoints[i] - mean) ** 2, 0) / N;
  const stdPop = Math.sqrt(varPop);
  const varSample = N > 1 ? frequencies.reduce((sum, f, i) => sum + f * (midpoints[i] - mean) ** 2, 0) / (N - 1) : NaN;
  const stdSample = Math.sqrt(varSample);
  const cumFreq = [];
  let sum = 0;
  for (let f of frequencies) {
    sum += f;
    cumFreq.push(sum);
  }

  const rows = intervals.map((interval, i) => {
    return `
      <tr>
        <td>${interval[0]}â€“${interval[1]}</td>
        <td>${frequencies[i]}</td>
        <td>${midpoints[i].toFixed(2)}</td>
        <td>${cumFreq[i]}</td>
        <td>${(cumFreq[i] / N * 100).toFixed(2)}%</td>
      </tr>`;
  });

  document.getElementById("results").innerHTML = `
    <div id="exportContent">
      <h2>ðŸ“Š Oversigt over data</h2>
      <table>
        <tr><th>Interval</th><th>Hyppighed</th><th>Midtpunkt</th><th>Kum. hyppighed</th><th>Kum. frekvens (%)</th></tr>
        ${rows.join("")}
      </table>
      <h2>ðŸ“‹ Statistik</h2>
      <table>
        <tr><th>Parameter</th><th>VÃ¦rdi</th></tr>
        <tr><td>n</td><td>${N}</td></tr>
        <tr><td>MiddelvÃ¦rdi</td><td>${mean.toFixed(2)}</td></tr>
        <tr><td>Populationsvarians</td><td>${varPop.toFixed(2)}</td></tr>
        <tr><td>Populationsspredning</td><td>${stdPop.toFixed(2)}</td></tr>
        <tr><td>StikprÃ¸vevarians</td><td>${varSample.toFixed(2)}</td></tr>
        <tr><td>StikprÃ¸vespredning</td><td>${stdSample.toFixed(2)}</td></tr>
      </table>
    </div>`;

  globalData = { intervals, frequencies, N, cumFreq, midpoints };

  showSumkurve();
  showHistogram();
  document.getElementById("fraktilResultat").innerHTML = "";
}

function interpolateXforP(p) {
  const { intervals, frequencies, N, cumFreq } = globalData;
  if (!intervals) return null;
  const target = p * N;
  for (let i = 0; i < frequencies.length; i++) {
    if (cumFreq[i] >= target) {
      const [a, b] = intervals[i];
      const F = i > 0 ? cumFreq[i - 1] : 0;
      const f_i = frequencies[i];
      const h = b - a;
      const xVal = a + ((target - F) / f_i) * h;
      return xVal;
    }
  }
  return null;
}

function interpolatePforX(x) {
  const { intervals, frequencies, N } = globalData;
  if (!intervals) return null;
  let totalFreq = 0;
  for (let i = 0; i < intervals.length; i++) {
    const [a, b] = intervals[i];
    if (x < a) {
      return 0;
    }
    if (x >= a && x <= b) {
      const f_i = frequencies[i];
      const h = b - a;
      const partialFreq = ((x - a) / h) * f_i;
      const cumFreqBefore = intervals.slice(0, i).reduce((sum, intv, idx) => sum + frequencies[idx], 0);
      return (cumFreqBefore + partialFreq) / N;
    }
    totalFreq += frequencies[i];
  }
  return 1;
}

function showSumkurve() {
  const { intervals, frequencies, N, cumFreq, midpoints } = globalData;
  if (!intervals) return;
  const labels = intervals.map(([a, b]) => `${a}â€“${b}`);
  const cumFreqPercent = cumFreq.map(f => (f / N) * 100);

  const ctx = document.getElementById("sumkurveCanvas").getContext("2d");
  if (sumChart) sumChart.destroy();

  sumChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: midpoints,
      datasets: [{
        label: 'Kumulativ frekvens (%)',
        data: cumFreqPercent,
        borderColor: 'green',
        fill: false,
        stepped: true,
        tension: 0,
        pointRadius: 3,
        pointHoverRadius: 6,
      }]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'x' },
          min: Math.min(...midpoints) - 1,
          max: Math.max(...midpoints) + 1,
        },
        y: {
          title: { display: true, text: 'Kumulativ frekvens (%)' },
          min: 0,
          max: 100,
          ticks: { stepSize: 10 },
        }
      },
      plugins: {
        legend: {
          display: true
        }
      },
    }
  });
}

function showHistogram() {
  const { intervals, frequencies } = globalData;
  if (!intervals) return;
  const labels = intervals.map(([a, b]) => `${a}â€“${b}`);
  const ctx = document.getElementById("histogramCanvas").getContext("2d");
  if (histogramChart) histogramChart.destroy();

  histogramChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Hyppighed',
        data: frequencies,
        backgroundColor: 'rgba(54, 162, 235, 0.6)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          title: { display: true, text: 'Interval' }
        },
        y: {
          beginAtZero: true,
          title: { display: true, text: 'Hyppighed' }
        }
      },
      plugins: {
        legend: { display: false }
      }
    }
  });
}

function beregnFraktiler() {
  // Indsaml og filtrer p-fraktil inputs
  const pInputsRaw = [
    document.getElementById("fraktilInput1").value,
    document.getElementById("fraktilInput2").value,
    document.getElementById("fraktilInput3").value,
  ];
  const pInputs = pInputsRaw
    .map(v => Number(v))
    .filter(v => !isNaN(v) && v > 0 && v < 1);

  // Indsaml og filtrer x-vÃ¦rdi inputs
  const xInputsRaw = [
    document.getElementById("xInput1").value,
    document.getElementById("xInput2").value,
    document.getElementById("xInput3").value,
  ];
  const xInputs = xInputsRaw
    .map(v => v.trim())
    .filter(v => v !== "")
    .map(v => Number(v))
    .filter(v => !isNaN(v));

  const fraktiler = [];
  for (let p of pInputs) {
    const xVal = interpolateXforP(p);
    if (xVal !== null) fraktiler.push({ p, xVal });
  }

  const pVaerdier = [];
  for (let x of xInputs) {
    const pVal = interpolatePforX(x);
    if (pVal !== null && pVal >= 0 && pVal <= 1) pVaerdier.push({ x, pVal });
  }

  // GenindlÃ¦s sumkurven for at fjerne tidligere ekstra linjer
  showSumkurve();

  const ctx = document.getElementById("sumkurveCanvas").getContext("2d");

  // Tegn stiplede linjer for fraktiler (grÃ¸n)
  fraktiler.forEach(({ p, xVal }) => {
    drawDottedLine(ctx, xVal, 0, xVal, p * 100, "green");  // lodret linje (p skaleret til procent)
    drawDottedLine(ctx, 0, p * 100, xVal, p * 100, "green");    // vandret linje (fra x=0 til xVal)
  });

  // Tegn stiplede linjer for p-vÃ¦rdier (blÃ¥)
  pVaerdier.forEach(({ x, pVal }) => {
    drawDottedLine(ctx, x, 0, x, pVal * 100, "blue");    // lodret linje (p skaleret til procent)
    drawDottedLine(ctx, 0, pVal * 100, x, pVal * 100, "blue"); // vandret linje (fra x=0 til x)
  });

  let tekst = "";
  if (fraktiler.length > 0) {
    tekst += "Fraktiler:\n";
    fraktiler.forEach(({ p, xVal }) => {
      tekst += `p = ${p.toFixed(3)} â†’ x = ${xVal.toFixed(3)}\n`;
    });
  }
  if (pVaerdier.length > 0) {
    tekst += "\nP-vÃ¦rdier:\n";
    pVaerdier.forEach(({ x, pVal }) => {
      tekst += `x = ${x.toFixed(3)} â†’ p = ${pVal.toFixed(3)}\n`;
    });
  }
  document.getElementById("fraktilResultat").textContent = tekst.trim();
}

function drawDottedLine(ctx, x1, y1, x2, y2, color) {
  const chartArea = sumChart.chartArea;
  if (!chartArea) return;

  // Omregn data-koordinater til pixels pÃ¥ canvas
  const px1 = sumChart.scales.x.getPixelForValue(x1);
  const py1 = sumChart.scales.y.getPixelForValue(y1);
  const px2 = sumChart.scales.x.getPixelForValue(x2);
  const py2 = sumChart.scales.y.getPixelForValue(y2);

  ctx.save();
  ctx.strokeStyle = color;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();

  // SÃ¸rg for linjen gÃ¥r fra lavere til hÃ¸jere pixel x for vandrette linjer
  if (y1 === y2 && px2 < px1) {
    ctx.moveTo(px2, py2);
    ctx.lineTo(px1, py1);
  } else {
    ctx.moveTo(px1, py1);
    ctx.lineTo(px2, py2);
  }
  ctx.stroke();
  ctx.restore();
}
</script>

</body>
</html>
